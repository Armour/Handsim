# README.md
---
### mips.py:
用于将汇编代码转成机器码，直接 python mips.py 即可，会自动读入 test.txt 输出结果至 out

### dismips.py:
用于将机器吗转换成汇编代码，直接 python dismips.py 即可，会自动读入 out 输出结果至 back.txt

### assembleDict.py:
这是将汇编代码转换成机器码时的字典，不用进行编译，会自动被 import 到 mips.py 里面

### disassembleDict.py:
这是将机器码转换成汇编代码时的字典，不用进行编译，会自动被 import 到 dismips.py 里面


#### PS: 为了便于调试，暂时使用了非二进制文件的普通字符串输出，正式合在一起时再做商议与修改

# 目前支持指令：

* R类型 全部
* I类型 全部
* J类型 全部 （有些小bug 等下修改
* 伪指令 未完成
* 格式指令 未完成

# 目前测试样例与结果：

### 汇编代码输入：

``` input: test.txt

 add $s0, $t0  , $t1 #dededefewf
shit:   sub    $s0, $      s0, $t0  # hahaha
beq $s0, $  zero  , rr   
beq  $s1, $s0, 1
    sw $s1, 2(  $t0) #defe efwfwef (f we)
rr:    lw $v0, 2*(3-1)( $t0  )#ha
j  0x03   
5*8:    j   shit
j 5*8

addi $t0 $zero 1-3+4*(3-1)
add $t1 $t0 $s1

```

### 机器码输出：

``` output: out

00000001000010011000000000100000
00000010000010001000000000100010
00010010000000000000000000010100
00010010001100000000000000010000
10101101000100010000000000000010
10001101000000100000000000000100
00001000000000000000000000100100
00001000000000000000000000000100
00001000000000000000000000011100
00100000000010000000000000000110
00000001000100010100100000100000

``` 

### 反汇编代码过程结果：

``` output: back.txt

        add $s0, $t0, $t1
mark_1: sub $s0, $s0, $t0
        beq $s0, $zero, mark_5
        beq $s1, $s0, mark_4
mark_4: sw $s1, 2($t0)
mark_5: lw $v0, 4($t0)
        j mark_9
mark_7: j mark_1
        j mark_7
mark_9: addi $t0, $zero, 6
        add $t1, $t0, $s1

```

# 待完成：

* J类型bug修正
* 伪指令完成
* 错误提示